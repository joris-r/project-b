
grammar;


extern {
    enum Tok {
        "MACHINE"            syntax::Token<&'input str>::Keyword(),
        "IMPLEMENTATION"     syntax::Token<&'input str>::Keyword(),
        "CONSTRAINTS"        syntax::Token<&'input str>::Keyword(),
        "CONCRETE_VARIABLES" syntax::Token<&'input str>::Keyword(),
        "INVARIANT"          syntax::Token<&'input str>::Keyword(),
        "INITIALISATION"     syntax::Token<&'input str>::Keyword(),
        "OPERATIONS"         syntax::Token<&'input str>::Keyword(),
        "END"                syntax::Token<&'input str>::Keyword(),
        "PRE"                syntax::Token<&'input str>::Keyword(),
        "THEN"               syntax::Token<&'input str>::Keyword(),
        "VAR"                syntax::Token<&'input str>::Keyword(),
        "IN"                 syntax::Token<&'input str>::Keyword(),
        "WHILE"              syntax::Token<&'input str>::Keyword(),
        "DO"                 syntax::Token<&'input str>::Keyword(),
        "INVARIANT"          syntax::Token<&'input str>::Keyword(),
        "VARIANT"            syntax::Token<&'input str>::Keyword(),
        "("                  syntax::Token<&'input str>::,
        ")"                  syntax::Token<&'input str>::,
        "{"                  syntax::Token<&'input str>::,
        "}"                  syntax::Token<&'input str>::,
        "["                  syntax::Token<&'input str>::,
        "]"                  syntax::Token<&'input str>::,
        ","                  syntax::Token<&'input str>::,
        ":"                  syntax::Token<&'input str>::,
        "&"                  syntax::Token<&'input str>::,
        ".."                 syntax::Token<&'input str>::,
        "-->"                syntax::Token<&'input str>::,
        ":="                 syntax::Token<&'input str>::,
        "<--"                syntax::Token<&'input str>::,
        "="                  syntax::Token<&'input str>::,
        ";"                  syntax::Token<&'input str>::,
        "◦"                  syntax::Token<&'input str>::,
        "×"                  syntax::Token<&'input str>::,
        "\\/"                syntax::Token<&'input str>::,
        "/\\"                syntax::Token<&'input str>::,
        "%"                  syntax::Token<&'input str>::,
        "|"                  syntax::Token<&'input str>::,
        "-"                  syntax::Token<&'input str>::,
        "+"                  syntax::Token<&'input str>::,
        "·"                  syntax::Token<&'input str>::,
        "/"                  syntax::Token<&'input str>::,
        "<|"                 syntax::Token<&'input str>::,
        Identifier           syntax::Token<&'input str>::,
        Number               syntax::Token<&'input str>::,
    }
}


pub Component = Decl_component Header Statements "END";

Decl_component = { "MACHINE", "REFINEMENT", "IMPLEMENTATION" };

Header = Identifier Paren_ident_list?;

Statements = Statement*;

Statement = {
    "REFINES" Ident_list,
    "CONCRETE_VARIABLES" Ident_list,
    "CONSTRAINTS" Expression,
    "INVARIANT" Expression,
    "INITIALISATION" Substitution,
    "OPERATIONS" Operation_list,
};

Operation_list = Dummy<Operation,";">;

Operation = (Ident_list "<--")? <Identifier> Paren_ident_list? "=" Substitution;

Substitution = {
    "BEGIN" <Substitution2> "END",
    "PRE" Expression "THEN" <Substitution2> "END",
    "VAR" Ident_list "IN" <Substitution2> "END",
    "WHILE" Expression "DO" <Substitution2>
                       "INVARIANT" Expression
                       "VARIANT" Expression
                       "END",
};

Substitution2 = {
    Substitution2 ";" <Substitution3>,
    Substitution2 "||" <Substitution3>,
    <Substitution3>,
};

Substitution3 = {
    Expression ":=" <Expression>,
    <Substitution>,
};

Expression = {
    Expression "<=>" <Expression2>,
    Expression "=>" <Expression2>,
    <Expression2>,
};

Expression2 = {
    Expression2 "&" <Expression3>,
    Expression2 "or" <Expression3>,
    <Expression3>,
};

Expression3 = {
    Expression3 ":" <Expression4>,
    Expression3 "<=" <Expression4>,
    Expression3 "=" <Expression4>,
    <Expression4>,
};

Expression4 = {
    Expression4 "-->" <Expression5>,
    <Expression5>,
};

Expression5 = {
    Expression5 "<|" <Expression6>,
    Expression5 r"\/" <Expression6>,
    Expression5 "◦" <Expression6>,
    Expression5 "×" <Expression6>,
    <Expression6>,
};

Expression6 = {
    Expression6 ".." <Expression7>,
    <Expression7>,
};

Expression7 = {
    Expression7 "+" <Expression8>,
    Expression7 "-" <Expression8>,
    <Expression8>,
};

Expression8 = {
    Expression8 "·" <Expression9>,
    Expression8 "/" <Expression9>,
    Expression8 "mod" <Expression9>,
    <Expression9>,
};

Expression9 = {
    "-" <Expression9>,
    "not" <Expression9>,
    <Expression10>,
};

Expression10 = {
    Expression10 <Expression11>,
    <Expression11>,
};

Expression11 = {
    <Identifier> "$0"?,
    <Number>,
    "(" <Comma_sep_expr> ")",
    "{" <Comma_sep_expr> "}",
    "%" Ident_or_paren_ident_list "." "(" Expression "|" <Expression> ")",
};

Comma_sep_expr = Dummy<Expression,",">;

Ident_or_paren_ident_list = { Identifier, Paren_ident_list };

Paren_ident_list = "(" <Ident_list> ")"  ;

Ident_list = Dummy<Identifier,",">;



// Macro -----------------------------------

Dummy<T,S>: T = {
    <v:(<T> S)*> <e:T?> => match e {
        None => "dummy",
        Some(e) => {
            e
        }
    }
};

ListSep<T,S>: Vec<T> = {
    <v:(<T> S)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};