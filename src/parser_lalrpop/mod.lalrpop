
grammar<'input>(text: &'input str)["LALR(1)"];

use syntax::Token;

extern {
    enum Token<'input> {
        "MACHINE"            => Token::KwMachine,
        "IMPLEMENTATION"     => Token::KwImplementation,
        "CONSTRAINTS"        => Token::KwConstraints,
        "REFINES"            => Token::KwRefines,
        "CONCRETE_VARIABLES" => Token::KwConcreteVariables,
        "INVARIANT"          => Token::KwInvariant,
        "INITIALISATION"     => Token::KwInitialisation,
        "OPERATIONS"         => Token::KwOperations,
        "BEGIN"              => Token::KwBegin,
        "END"                => Token::KwEnd,
        "PRE"                => Token::KwPre,
        "THEN"               => Token::KwThen,
        "VAR"                => Token::KwVar,
        "IN"                 => Token::KwIn,
        "WHILE"              => Token::KwWhile,
        "DO"                 => Token::KwDo,
        "VARIANT"            => Token::KwVariant,
        "or"                 => Token::KwOr,
        "mod"                => Token::KwMod,
        "not"                => Token::KwNot,

        "("   => Token::OpLpar,       
        ")"   => Token::OpRpar,       
        "{"   => Token::OpLbrace,     
        "}"   => Token::OpRbrace,     
        "["   => Token::OpLbracket,   
        "]"   => Token::OpRbracket,   
        ","   => Token::OpComma,      
        ":"   => Token::OpColon,      
        "&"   => Token::OpAmpersand , 
        "="   => Token::OpEqual,      
        ";"   => Token::OpSemicolon,  
        "◦"   => Token::OpBullet,     
        "×"   => Token::OpCross,      
        "%"   => Token::OpPercent,    
        "|"   => Token::OpVbar,       
        "-"   => Token::OpMinus,      
        "+"   => Token::OpPlus,       
        "·"   => Token::OpMdot,       
        "/"   => Token::OpSlash,
        "."   => Token::OpDot,
        "<|"  => Token::OpDomrestr,   
        ".."  => Token::OpInter,      
        ":="  => Token::OpAssign, 
        "||"  => Token::OpDoubleBar,
        "=>"  => Token::OpImply,
        "<="  => Token::OpLeq,
        "\\/" => Token::OpSimpleunion,
        "/\\" => Token::OpSimpleinter,
        "<=>" => Token::OpEquiv,
        "-->" => Token::OpTotalfun,   
        "<--" => Token::OpOutparam,   
        
        Integer    => Token::Integer(<&'input str>),
        Float      => Token::Float(<&'input str>),
        Identifier => Token::Identifier(<&'input str>),
    }
}


pub Component = Decl_component Header Statements "END";

Decl_component = { "MACHINE", "IMPLEMENTATION" };

Header = Identifier Paren_ident_list?;

Statements = Statement*;

Statement = {
    "REFINES" Ident_list,
    "CONCRETE_VARIABLES" Ident_list,
    "CONSTRAINTS" Expression,
    "INVARIANT" Expression,
    "INITIALISATION" Substitution,
    "OPERATIONS" Operation_list,
};

Operation_list = Dummy<Operation,";">;

Operation = (Ident_list "<--")? <Identifier> Paren_ident_list? "=" Substitution;

Substitution = {
    "BEGIN" <Substitution2> "END",
    "PRE" Expression "THEN" <Substitution2> "END",
    "VAR" Ident_list "IN" <Substitution2> "END",
    "WHILE" Expression "DO" <Substitution2>
                       "INVARIANT" Expression
                       "VARIANT" Expression
                       "END",
};

Substitution2 = {
    Substitution2 ";" <Substitution3>,
    Substitution2 "||" <Substitution3>,
    <Substitution3>,
};

Substitution3 = {
    Expression ":=" <Expression>,
    <Substitution>,
};

Expression = {
    Expression "<=>" <Expression2>,
    Expression "=>" <Expression2>,
    <Expression2>,
};

Expression2 = {
    Expression2 "&" <Expression3>,
    Expression2 "or" <Expression3>,
    <Expression3>,
};

Expression3 = {
    Expression3 ":" <Expression4>,
    Expression3 "<=" <Expression4>,
    Expression3 "=" <Expression4>,
    <Expression4>,
};

Expression4 = {
    Expression4 "-->" <Expression5>,
    <Expression5>,
};

Expression5 = {
    Expression5 "<|" <Expression6>,
    Expression5 "\\/" <Expression6>,
    Expression5 "/\\" <Expression6>,
    Expression5 "◦" <Expression6>,
    Expression5 "×" <Expression6>,
    <Expression6>,
};

Expression6 = {
    Expression6 ".." <Expression7>,
    <Expression7>,
};

Expression7 = {
    Expression7 "+" <Expression8>,
    Expression7 "-" <Expression8>,
    <Expression8>,
};

Expression8 = {
    Expression8 "·" <Expression9>,
    Expression8 "/" <Expression9>,
    Expression8 "mod" <Expression9>,
    <Expression9>,
};

Expression9 = {
    "-" <Expression9>,
    "not" <Expression9>,
    <Expression10>,
};

Expression10 = {
    Expression10 <Expression11>,
    <Expression11>,
};

Expression11 = {
    <Identifier>,
    <Number>,
    "(" <Comma_sep_expr> ")",
    "{" <Comma_sep_expr> "}",
    "%" Ident_or_paren_ident_list "." "(" Expression "|" <Expression> ")",
};

Comma_sep_expr = Dummy<Expression,",">;

Ident_or_paren_ident_list = { Identifier, Paren_ident_list };

Paren_ident_list = "(" <Ident_list> ")"  ;

Ident_list = Dummy<Identifier,",">;

Number = {
    Integer,
    Float,
};


// Macro -----------------------------------

Dummy<T,S>: T = {
    <v:(<T> S)*> <e:T?> => match e {
        None => "dummy",
        Some(e) => {
            e
        }
    }
};

ListSep<T,S>: Vec<T> = {
    <v:(<T> S)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};